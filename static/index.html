<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<title>Model Merger 2</title>
<link rel="stylesheet" href="https://unpkg.com/litegraph.js/css/litegraph.css" />
<style>
body, html {margin:0; padding:0; height:100%; overflow:hidden; background:#222; color:#eee;}
#topbar {position:fixed; top:0; left:0; right:0; height:40px; background:#111; color:#eee; display:flex; justify-content:flex-end; align-items:center; padding:0 10px; z-index:10;}
#sidebar {position:fixed; top:40px; left:0; bottom:0; width:180px; overflow:auto; border-right:1px solid #555; padding:10px; background:#333; z-index:5;}
#graph-container {position:absolute; top:40px; left:180px; right:0; bottom:0; overflow:hidden; z-index:0;}
.node-item {border:1px solid #555; padding:4px; margin-bottom:4px; cursor:grab; background:#444; color:#eee;}
.node-item:active {cursor:grabbing;}
#graph {background:#2b2b2b; width:100%; height:100%; display:block;}
</style>
</head>
<body>
<div id="topbar">
  <button id="run">Run</button>
  <button id="save">Save Graph</button>
  <button id="load">Load Graph</button>
</div>
<div id="sidebar"></div>
<div id="graph-container"><canvas id="graph"></canvas></div>
<script src="https://unpkg.com/litegraph.js/build/litegraph.min.js"></script>
<script>
var graph = new LGraph();
var container = document.getElementById('graph-container');
var canvasElement = document.getElementById('graph');
var canvas = new LGraphCanvas(canvasElement, graph);

function fitCanvas(){
  var rect = container.getBoundingClientRect();
  canvas.resize(rect.width, rect.height);
}
window.addEventListener('resize', fitCanvas);
fitCanvas();

// remove default browser nodes and builtins
if (LiteGraph.clearRegisteredTypes) {
  LiteGraph.clearRegisteredTypes();
} else {
  LiteGraph.registered_node_types = {};
  LiteGraph.Nodes = {};
}

var nodeCategories = {};
var contextMenuData = null;

fetch('/node_specs').then(r => r.json()).then(function(specs){
  specs.forEach(function(spec){
    registerSpec(spec);
  });
  buildContextMenuData();
});

function buildContextMenuData(){
  contextMenuData = [];
  for(const cat in nodeCategories){
    var submenu = nodeCategories[cat].map(function(type){
      var info = LiteGraph.registered_node_types[type];
      var title = (info && info.title) || type;
      return {content: title, nodeType: type};
    });
    contextMenuData.push({content: cat.replace(/_/g,' '), submenu: submenu});
  }
}

function addSidebarItem(type, title){
  var sidebar = document.getElementById('sidebar');
  var item = document.createElement('div');
  item.className = 'node-item';
  item.draggable = true;
  item.dataset.node = type;
  item.textContent = title || type;
  sidebar.appendChild(item);
  item.addEventListener('dragstart', function(ev){
    ev.dataTransfer.setData('node-type', type);
  });
}

function registerSpec(spec){
  var type = spec.type;
  var category = spec.category || type.split('/')[0];
  function NodeClass(){
    this.properties = Object.assign({}, spec.properties || {});
    var self = this;
    (spec.inputs || []).forEach(function(i){ self.addInput(i.name, i.type); });
    (spec.outputs || []).forEach(function(o){ self.addOutput(o.name, o.type); });
    (spec.widgets || []).forEach(function(w){
      if(w.kind === 'button'){
        self.addWidget('button', w.name, '', function(){
          fetch(w.action).then(r=>r.json()).then(function(data){
            if(w.assignTo){
              self.properties[w.assignTo] = data.path || data.value || '';
              updateBoundWidgets(self, w.assignTo);
              self.setDirtyCanvas(true);
            }
          });
        });
      } else if(w.kind === 'text'){
        self.addWidget('text', w.name, self.properties[w.bind] || '', function(v){
          self.properties[w.bind] = v;
        }, Object.assign({bindProp:w.bind}, w.options||{}));
      } else if(w.kind === 'slider'){
        self.addWidget('slider', w.name, self.properties[w.bind] || 0, function(v){
          self.properties[w.bind] = v;
        }, Object.assign({bindProp:w.bind}, w.options||{}));
      } else if(w.kind === 'number'){
        self.addWidget('number', w.name, self.properties[w.bind] || 0, function(v){
          self.properties[w.bind] = v;
        }, Object.assign({bindProp:w.bind}, w.options||{}));
      } else if(w.kind === 'checkbox'){
        self.addWidget('toggle', w.name, self.properties[w.bind] || false, function(v){
          self.properties[w.bind] = v;
        }, Object.assign({bindProp:w.bind}, w.options||{}));
      } else if(w.kind === 'combo'){
        self.addWidget('combo', w.name, self.properties[w.bind] || '', function(v){
          self.properties[w.bind] = v;
        }, Object.assign({bindProp:w.bind}, w.options||{}));
      } else if(w.kind === 'color'){
        self.addWidget('color', w.name, self.properties[w.bind] || '#ffffff', function(v){
          self.properties[w.bind] = v;
        }, Object.assign({bindProp:w.bind}, w.options||{}));
      } else if(w.kind === 'textarea'){
        self.addWidget('text', w.name, self.properties[w.bind] || '', function(v){
          self.properties[w.bind] = v;
        }, Object.assign({bindProp:w.bind, multiline:true}, w.options||{}));
      }
    });
  }
  NodeClass.title = spec.title || type;
  NodeClass.prototype.serialize_widgets = true;
  LiteGraph.registerNodeType(type, NodeClass);
  if(!nodeCategories[category]){ nodeCategories[category] = []; }
  nodeCategories[category].push(type);
  addSidebarItem(type, NodeClass.title);
}

function updateBoundWidgets(node, prop){
  if(!node.widgets) return;
  node.widgets.forEach(function(w){
    if(w.options && w.options.bindProp === prop){
      w.value = node.properties[prop];
    }
  });
}

function syncNodeWidgets(node){
  if(!node.widgets) return;
  node.widgets.forEach(function(w){
    if(w.options && w.options.bindProp){
      w.value = node.properties[w.options.bindProp];
    }
  });
}

document.getElementById('graph').addEventListener('dragover', function(ev){ ev.preventDefault(); });
document.getElementById('graph').addEventListener('drop', function(ev){
  ev.preventDefault();
  var type = ev.dataTransfer.getData('node-type');
  var pos = canvas.convertEventToCanvasOffset(ev);
  var node = LiteGraph.createNode(type);
  node.pos = [pos[0], pos[1]];
  graph.add(node);
});

canvas.canvas.addEventListener('contextmenu', function(ev){
  ev.preventDefault();
  var pos = canvas.convertEventToCanvasOffset(ev);
  if(!contextMenuData){ return; }
  var menu = contextMenuData.map(function(cat){
    return {content: cat.content, submenu: cat.submenu.map(function(item){
      return {content: item.content, callback: function(){
        var node = LiteGraph.createNode(item.nodeType);
        node.pos = pos.slice();
        graph.add(node);
      }};
    })};
  });
  new LiteGraph.ContextMenu(menu, {event: ev});
});

// Run button
var graphHistory = [];
var restoring = false;
function pushHistory(){
  if(restoring) return;
  graphHistory.push(graph.serialize());
  if(graphHistory.length > 20) graphHistory.shift();
}
graph.onAfterChange = pushHistory;
pushHistory();

function undoHistory(){
  if(graphHistory.length < 2) return;
  graphHistory.pop();
  var state = graphHistory[graphHistory.length-1];
  restoring = true;
  graph.clear();
  graph.configure(state);
  if(graph._nodes) graph._nodes.forEach(syncNodeWidgets);
  restoring = false;
  canvas.setDirty(true, true);
}

document.addEventListener('keydown', function(ev){
  canvas.processKey(ev);
  if(ev.ctrlKey){
    if(ev.key === 'z'){ undoHistory(); ev.preventDefault(); }
    if(ev.key === 'c'){ canvas.copyToClipboard(); ev.preventDefault(); }
    if(ev.key === 'v'){ canvas.pasteFromClipboard(); ev.preventDefault(); }
  }
});
document.addEventListener('keyup', function(ev){ canvas.processKey(ev); });

document.getElementById('run').onclick = function(){
  var data = graph.serialize();
  fetch('/run_stream', {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(data)
  }).then(function(resp){
    var reader = resp.body.getReader();
    var decoder = new TextDecoder();
    var buffer = '';
    var last = null;
    function process(line){
      if(!line.trim()) return;
      var info = JSON.parse(line);
      if(info.node !== undefined){
        if(last){ last.boxcolor = last._prevBoxColor || null; }
        var node = graph.getNodeById(info.node);
        if(node){
          node._prevBoxColor = node.boxcolor;
          node.boxcolor = '#0f0';
          last = node;
          canvas.draw(true,false);
        }
      } else if(info.status === 'done'){
        if(last){ last.boxcolor = last._prevBoxColor || null; }
        canvas.draw(true,false);
        alert('Finished');
      }
    }
    function read(){
      reader.read().then(function(result){
        if(result.done){
          if(buffer) process(buffer);
          return;
        }
        buffer += decoder.decode(result.value, {stream:true});
        var lines = buffer.split('\n');
        buffer = lines.pop();
        lines.forEach(process);
        read();
      });
    }
    read();
  });
};

document.getElementById('save').onclick = function(){
  var data = graph.serialize();
  fetch('/choose_save_file').then(r=>r.json()).then(function(resp){
    if(!resp.path) return;
    fetch('/save_graph', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({path: resp.path, graph: data})
    }).then(r=>r.json()).then(function(){ alert('Saved'); });
  });
};

document.getElementById('load').onclick = function(){
  fetch('/choose_file').then(r=>r.json()).then(function(resp){
    if(!resp.path) return;
    fetch('/load_graph?path='+encodeURIComponent(resp.path))
      .then(r=>r.json())
      .then(function(g){
        graph.clear();
        graph.configure(g);
        if(graph._nodes)
          graph._nodes.forEach(syncNodeWidgets);
      });
  });
};

graph.start();
</script>
</body>
</html>
