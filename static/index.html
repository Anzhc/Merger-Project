<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<title>Model Merger 2</title>
<link rel="stylesheet" href="https://unpkg.com/litegraph.js/css/litegraph.css" />
<style>
body, html {margin:0; padding:0; height:100%; overflow:hidden; background:#222; color:#eee;}
#topbar {position:fixed; top:0; left:0; right:0; height:40px; background:#111; color:#eee; display:flex; justify-content:flex-end; align-items:center; padding:0 10px; z-index:10;}
#sidebar {position:fixed; top:40px; left:0; bottom:0; width:180px; overflow:auto; border-right:1px solid #555; padding:10px; background:#333; z-index:5;}
#graph-container {position:absolute; top:40px; left:180px; right:0; bottom:0; overflow:hidden; z-index:0;}
.category-header{font-weight:bold;margin-top:8px;display:flex;justify-content:space-between;cursor:pointer;}
.category-content{margin-bottom:8px;}
.node-item {border:1px solid #555; padding:4px; margin-bottom:4px; cursor:grab; background:#444; color:#eee;}
.node-item:active {cursor:grabbing;}
#graph {background:#2b2b2b; width:100%; height:100%; display:block;}
#node-tooltip{position:fixed;background:#333;color:#eee;padding:4px 6px;border-radius:4px;pointer-events:none;z-index:20;display:none;font-size:12px;max-width:200px;}
</style>
</head>
<body>
<div id="topbar">
  <button id="run">Run</button>
  <button id="save">Save Graph</button>
  <button id="load">Load Graph</button>
</div>
<div id="sidebar"></div>
<div id="graph-container"><canvas id="graph"></canvas></div>
<div id="node-tooltip"></div>
<script src="https://unpkg.com/litegraph.js/build/litegraph.min.js"></script>
<script>
// tweak widget text rendering so long paths show the end of the string
(function(){
  const orig = LiteGraph.LGraphCanvas && LiteGraph.LGraphCanvas.prototype.drawNodeWidgets;
  if(!orig) return;
  LiteGraph.LGraphCanvas.prototype.drawNodeWidgets = function(node,posY,ctx,active_widget){
    if(!node.widgets || !node.widgets.length) return 0;
    const width = node.size[0];
    const widgets = node.widgets;
    posY += 2;
    const H = LiteGraph.NODE_WIDGET_HEIGHT;
    const show_text = this.ds.scale > 0.5;
    ctx.save();
    ctx.globalAlpha = this.editor_alpha;
    const outline_color = LiteGraph.WIDGET_OUTLINE_COLOR;
    const background_color = LiteGraph.WIDGET_BGCOLOR;
    const text_color = LiteGraph.WIDGET_TEXT_COLOR;
    const secondary_text_color = LiteGraph.WIDGET_SECONDARY_TEXT_COLOR;
    const margin = 15;

    for(let i=0; i<widgets.length; ++i){
      const w = widgets[i];
      let y = posY;
      if(w.y) y = w.y;
      w.last_y = y;
      ctx.strokeStyle = outline_color;
      ctx.fillStyle = '#222';
      ctx.textAlign = 'left';
      if(w.disabled) ctx.globalAlpha *= 0.5;
      const widget_width = w.width || width;
      switch(w.type){
      case 'button':
        if(w.clicked){
          ctx.fillStyle = '#AAA';
          w.clicked = false;
          this.dirty_canvas = true;
        }
        ctx.fillRect(margin, y, widget_width - margin * 2, H);
        if(show_text && !w.disabled)
          ctx.strokeRect(margin, y, widget_width - margin * 2, H);
        if(show_text){
          ctx.textAlign = 'center';
          ctx.fillStyle = text_color;
          ctx.fillText(w.label || w.name, widget_width * 0.5, y + H * 0.7);
        }
        break;
      case 'toggle':
        ctx.textAlign = 'left';
        ctx.strokeStyle = outline_color;
        ctx.fillStyle = background_color;
        ctx.beginPath();
        if(show_text)
          ctx.roundRect(margin, y, widget_width - margin * 2, H, [H * 0.5]);
        else
          ctx.rect(margin, y, widget_width - margin * 2, H);
        ctx.fill();
        if(show_text && !w.disabled)
          ctx.stroke();
        ctx.fillStyle = w.value ? '#89A' : '#333';
        ctx.beginPath();
        ctx.arc(widget_width - margin * 2, y + H * 0.5, H * 0.36, 0, Math.PI * 2);
        ctx.fill();
        if(show_text){
          ctx.fillStyle = secondary_text_color;
          const label = w.label || w.name;
          if(label != null) ctx.fillText(label, margin * 2, y + H * 0.7);
          ctx.fillStyle = w.value ? text_color : secondary_text_color;
          ctx.textAlign = 'right';
          ctx.fillText(w.value ? (w.options.on || 'true') : (w.options.off || 'false'), widget_width - 40, y + H * 0.7);
        }
        break;
      case 'slider':
        ctx.fillStyle = background_color;
        ctx.fillRect(margin, y, widget_width - margin * 2, H);
        const range = w.options.max - w.options.min;
        let nvalue = (w.value - w.options.min) / range;
        if(nvalue < 0) nvalue = 0;
        if(nvalue > 1) nvalue = 1;
        ctx.fillStyle = w.options.hasOwnProperty('slider_color') ? w.options.slider_color : (active_widget == w ? '#89A' : '#678');
        ctx.fillRect(margin, y, nvalue * (widget_width - margin * 2), H);
        if(show_text && !w.disabled)
          ctx.strokeRect(margin, y, widget_width - margin * 2, H);
        if(w.marker){
          let marker_nvalue = (w.marker - w.options.min) / range;
          if(marker_nvalue < 0) marker_nvalue = 0;
          if(marker_nvalue > 1) marker_nvalue = 1;
          ctx.fillStyle = w.options.hasOwnProperty('marker_color') ? w.options.marker_color : '#AA9';
          ctx.fillRect(margin + marker_nvalue * (widget_width - margin * 2), y, 2, H);
        }
        if(show_text){
          ctx.textAlign = 'center';
          ctx.fillStyle = text_color;
          ctx.fillText(w.label || w.name + '  ' + Number(w.value).toFixed(w.options.precision != null ? w.options.precision : 3), widget_width * 0.5, y + H * 0.7);
        }
        break;
      case 'number':
      case 'combo':
        ctx.textAlign = 'left';
        ctx.strokeStyle = outline_color;
        ctx.fillStyle = background_color;
        ctx.beginPath();
        if(show_text)
          ctx.roundRect(margin, y, widget_width - margin * 2, H, [H * 0.5]);
        else
          ctx.rect(margin, y, widget_width - margin * 2, H);
        ctx.fill();
        if(show_text){
          if(!w.disabled) ctx.stroke();
          ctx.fillStyle = text_color;
          if(!w.disabled){
            ctx.beginPath();
            ctx.moveTo(margin + 16, y + 5);
            ctx.lineTo(margin + 6, y + H * 0.5);
            ctx.lineTo(margin + 16, y + H - 5);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(widget_width - margin - 16, y + 5);
            ctx.lineTo(widget_width - margin - 6, y + H * 0.5);
            ctx.lineTo(widget_width - margin - 16, y + H - 5);
            ctx.fill();
          }
          ctx.fillStyle = secondary_text_color;
          ctx.fillText(w.label || w.name, margin * 2 + 5, y + H * 0.7);
          ctx.fillStyle = text_color;
          ctx.textAlign = 'right';
          if(w.type == 'number'){
            ctx.fillText(Number(w.value).toFixed(w.options.precision !== undefined ? w.options.precision : 3), widget_width - margin * 2 - 20, y + H * 0.7);
          }else{
            let v = w.value;
            if(w.options.values){
              let values = w.options.values;
              if(values.constructor === Function) values = values();
              if(values && values.constructor !== Array) v = values[w.value];
            }
            ctx.fillText(v, widget_width - margin * 2 - 20, y + H * 0.7);
          }
        }
        break;
      case 'string':
      case 'text':
        ctx.textAlign = 'left';
        ctx.strokeStyle = outline_color;
        ctx.fillStyle = background_color;
        ctx.beginPath();
        if(show_text)
          ctx.roundRect(margin, y, widget_width - margin * 2, H, [H * 0.5]);
        else
          ctx.rect(margin, y, widget_width - margin * 2, H);
        ctx.fill();
        if(show_text){
          if(!w.disabled) ctx.stroke();
          ctx.save();
          ctx.beginPath();
          ctx.rect(margin, y, widget_width - margin * 2, H);
          ctx.clip();
          ctx.fillStyle = secondary_text_color;
          const label = w.label || w.name;
          if(label != null) ctx.fillText(label, margin * 2, y + H * 0.7);
          ctx.fillStyle = text_color;
          ctx.textAlign = 'right';
          let text = String(w.value);
          if(text.length > 30) text = text.slice(-30);
          ctx.fillText(text, widget_width - margin * 2, y + H * 0.7);
          ctx.restore();
        }
        break;
      default:
        if(w.draw) w.draw(ctx, node, widget_width, y, H);
        break;
      }
      posY += (w.computeSize ? w.computeSize(widget_width)[1] : H) + 4;
      ctx.globalAlpha = this.editor_alpha;
    }
    ctx.restore();
    ctx.textAlign = 'left';
  };
})();
</script>
<script>
var graph = new LGraph();
var container = document.getElementById('graph-container');
var canvasElement = document.getElementById('graph');
var canvas = new LGraphCanvas(canvasElement, graph);
var tooltipElem = document.getElementById('node-tooltip');
var tooltipTimer = null;
var hoveredNode = null;

function fitCanvas(){
  var rect = container.getBoundingClientRect();
  canvas.resize(rect.width, rect.height);
}
window.addEventListener('resize', fitCanvas);
fitCanvas();

canvasElement.addEventListener('mousemove', function(ev){
  var pos = canvas.convertEventToCanvasOffset(ev);
  var node = graph.getNodeOnPos(pos[0], pos[1]);
  if(node !== hoveredNode){
    if(tooltipTimer){ clearTimeout(tooltipTimer); }
    tooltipElem.style.display = 'none';
    hoveredNode = node;
    if(node && node.constructor.tooltip){
      tooltipTimer = setTimeout(function(){
        tooltipElem.textContent = node.constructor.tooltip;
        tooltipElem.style.left = (ev.clientX + 10)+'px';
        tooltipElem.style.top = (ev.clientY + 10)+'px';
        tooltipElem.style.display = 'block';
      }, 600);
    }
  } else if(tooltipElem.style.display !== 'none'){
    tooltipElem.style.left = (ev.clientX + 10)+'px';
    tooltipElem.style.top = (ev.clientY + 10)+'px';
  }
});

canvasElement.addEventListener('mouseleave', function(){
  if(tooltipTimer){ clearTimeout(tooltipTimer); tooltipTimer = null; }
  tooltipElem.style.display = 'none';
  hoveredNode = null;
});

// remove default browser nodes and builtins
if (LiteGraph.clearRegisteredTypes) {
  LiteGraph.clearRegisteredTypes();
} else {
  LiteGraph.registered_node_types = {};
  LiteGraph.Nodes = {};
}


var categorySections = {};

function getCategoryContent(name){
  name = name || 'Other';
  if(categorySections[name]) return categorySections[name];
  var sidebar = document.getElementById('sidebar');
  var section = document.createElement('div');
  var header = document.createElement('div');
  header.className = 'category-header';
  var title = document.createElement('span');
  title.textContent = name;
  var toggle = document.createElement('span');
  toggle.textContent = '\u25B2';
  header.appendChild(title);
  header.appendChild(toggle);
  section.appendChild(header);
  var content = document.createElement('div');
  content.className = 'category-content';
  section.appendChild(content);
  toggle.onclick = function(){
    if(content.style.display === 'none'){
      content.style.display = '';
      toggle.textContent = '\u25B2';
    }else{
      content.style.display = 'none';
      toggle.textContent = '\u25BC';
    }
  };
  sidebar.appendChild(section);
  categorySections[name] = content;
  return content;
}

fetch('/node_specs').then(r => r.json()).then(function(specs){
  specs.sort(function(a,b){
    var ca = (a.node_category || a.category || '').toLowerCase();
    var cb = (b.node_category || b.category || '').toLowerCase();
    if(ca < cb) return -1;
    if(ca > cb) return 1;
    return 0;
  });
  specs.forEach(function(spec){
    registerSpec(spec);
  });
});


function addSidebarItem(type, title, category){
  var content = getCategoryContent(category);
  var item = document.createElement('div');
  item.className = 'node-item';
  item.draggable = true;
  item.dataset.node = type;
  item.textContent = title || type;
  content.appendChild(item);
  item.addEventListener('dragstart', function(ev){
    ev.dataTransfer.setData('node-type', type);
  });
}

function registerSpec(spec){
  var type = spec.type;
  var category = spec.node_category || spec.category || type.split('/')[0];
  function NodeClass(){
    this.properties = Object.assign({}, spec.properties || {});
    var self = this;
    (spec.inputs || []).forEach(function(i){ self.addInput(i.name, i.type); });
    (spec.outputs || []).forEach(function(o){ self.addOutput(o.name, o.type); });
    (spec.widgets || []).forEach(function(w){
      if(w.kind === 'button'){
        self.addWidget('button', w.name, '', function(){
          fetch(w.action).then(r=>r.json()).then(function(data){
            if(w.assignTo){
              self.properties[w.assignTo] = data.path || data.value || '';
              updateBoundWidgets(self, w.assignTo);
              self.setDirtyCanvas(true);
            }
          });
        });
      } else if(w.kind === 'text'){
        self.addWidget('text', w.name, self.properties[w.bind] || '', function(v){
          self.properties[w.bind] = v;
        }, Object.assign({bindProp:w.bind}, w.options||{}));
      } else if(w.kind === 'slider'){
        self.addWidget('slider', w.name, self.properties[w.bind] || 0, function(v){
          self.properties[w.bind] = v;
        }, Object.assign({bindProp:w.bind}, w.options||{}));
      } else if(w.kind === 'number'){
        self.addWidget('number', w.name, self.properties[w.bind] || 0, function(v){
          self.properties[w.bind] = v;
        }, Object.assign({bindProp:w.bind}, w.options||{}));
      } else if(w.kind === 'checkbox'){
        self.addWidget('toggle', w.name, self.properties[w.bind] || false, function(v){
          self.properties[w.bind] = v;
        }, Object.assign({bindProp:w.bind}, w.options||{}));
      } else if(w.kind === 'combo'){
        self.addWidget('combo', w.name, self.properties[w.bind] || '', function(v){
          self.properties[w.bind] = v;
        }, Object.assign({bindProp:w.bind}, w.options||{}));
      } else if(w.kind === 'color'){
        self.addWidget('color', w.name, self.properties[w.bind] || '#ffffff', function(v){
          self.properties[w.bind] = v;
        }, Object.assign({bindProp:w.bind}, w.options||{}));
      } else if(w.kind === 'textarea'){
        self.addWidget('text', w.name, self.properties[w.bind] || '', function(v){
          self.properties[w.bind] = v;
        }, Object.assign({bindProp:w.bind, multiline:true}, w.options||{}));
      }
    });
  }
  NodeClass.title = spec.title || type;
  NodeClass.tooltip = spec.tooltip || '';
  NodeClass.prototype.serialize_widgets = true;
  LiteGraph.registerNodeType(type, NodeClass);
  addSidebarItem(type, NodeClass.title, category);
}

function updateBoundWidgets(node, prop){
  if(!node.widgets) return;
  node.widgets.forEach(function(w){
    if(w.options && w.options.bindProp === prop){
      w.value = node.properties[prop];
    }
  });
}

function syncNodeWidgets(node){
  if(!node.widgets) return;
  node.widgets.forEach(function(w){
    if(w.options && w.options.bindProp){
      w.value = node.properties[w.options.bindProp];
    }
  });
}

document.getElementById('graph').addEventListener('dragover', function(ev){ ev.preventDefault(); });
document.getElementById('graph').addEventListener('drop', function(ev){
  ev.preventDefault();
  var type = ev.dataTransfer.getData('node-type');
  var pos = canvas.convertEventToCanvasOffset(ev);
  var node = LiteGraph.createNode(type);
  node.pos = [pos[0], pos[1]];
  graph.beforeChange();
  graph.add(node);
  graph.afterChange();
});

// Run button
var graphHistory = [];
var redoHistory = [];
var restoring = false;
function pushHistory(){
  if(restoring) return;
  graphHistory.push(JSON.parse(JSON.stringify(graph.serialize())));
  if(graphHistory.length > 20) graphHistory.shift();
  redoHistory.length = 0;
}
graph.onBeforeChange = pushHistory;
pushHistory();

function undoHistory(){
  if(graphHistory.length < 2) return;
  redoHistory.push(graphHistory.pop());
  var state = graphHistory[graphHistory.length-1];
  restoring = true;
  graph.clear();
  graph.configure(state);
  if(graph._nodes) graph._nodes.forEach(syncNodeWidgets);
  restoring = false;
  canvas.setDirty(true, true);
}

function redoHistoryAction(){
  if(redoHistory.length === 0) return;
  var state = redoHistory.pop();
  graphHistory.push(state);
  restoring = true;
  graph.clear();
  graph.configure(state);
  if(graph._nodes) graph._nodes.forEach(syncNodeWidgets);
  restoring = false;
  canvas.setDirty(true, true);
}

document.addEventListener('keydown', function(ev){
  canvas.processKey(ev);
  if(ev.ctrlKey){
    if(ev.key === 'z'){ undoHistory(); ev.preventDefault(); }
    if(ev.key === 'y'){ redoHistoryAction(); ev.preventDefault(); }
  }
});
document.addEventListener('keyup', function(ev){ canvas.processKey(ev); });

document.getElementById('run').onclick = function(){
  var data = graph.serialize();
  fetch('/run_stream', {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(data)
  }).then(function(resp){
    var reader = resp.body.getReader();
    var decoder = new TextDecoder();
    var buffer = '';
    var last = null;
    function process(line){
      if(!line.trim()) return;
      var info = JSON.parse(line);
      if(info.node !== undefined){
        if(last){ last.boxcolor = last._prevBoxColor || null; }
        var node = graph.getNodeById(info.node);
        if(node){
          node._prevBoxColor = node.boxcolor;
          node.boxcolor = '#0f0';
          last = node;
          canvas.draw(true,false);
        }
      } else if(info.status === 'done'){
        if(last){ last.boxcolor = last._prevBoxColor || null; }
        canvas.draw(true,false);
        alert('Finished');
      }
    }
    function read(){
      reader.read().then(function(result){
        if(result.done){
          if(buffer) process(buffer);
          return;
        }
        buffer += decoder.decode(result.value, {stream:true});
        var lines = buffer.split('\n');
        buffer = lines.pop();
        lines.forEach(process);
        read();
      });
    }
    read();
  });
};

document.getElementById('save').onclick = function(){
  var data = graph.serialize();
  fetch('/choose_save_file').then(r=>r.json()).then(function(resp){
    if(!resp.path) return;
    fetch('/save_graph', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({path: resp.path, graph: data})
    }).then(r=>r.json()).then(function(){ alert('Saved'); });
  });
};

document.getElementById('load').onclick = function(){
  fetch('/choose_file').then(r=>r.json()).then(function(resp){
    if(!resp.path) return;
    fetch('/load_graph?path='+encodeURIComponent(resp.path))
      .then(r=>r.json())
      .then(function(g){
        restoring = true;
        graph.clear();
        graph.configure(g);
        if(graph._nodes)
          graph._nodes.forEach(syncNodeWidgets);
        restoring = false;
        graphHistory = [graph.serialize()];
        redoHistory.length = 0;
      });
  });
};

graph.start();
</script>
</body>
</html>
